<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>avProjDoxygen: Recommended C coding rules for the NUCLEO project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">avProjDoxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Recommended C coding rules for the NUCLEO project</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md9"></a></p>
<h1><a class="anchor" id="autotoc_md10"></a>
C styles are shown in &lt;tt&gt;C_Style.c&lt;/tt&gt; and &lt;tt&gt;C_Style.h&lt;/tt&gt;</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Table of Contents</h2>
<ul>
<li>General rules</li>
<li>Comments</li>
<li>Functions</li>
<li>Variables</li>
<li>Structures, enumerations, typedefs</li>
<li>Compound statements</li>
<li>Switch statement</li>
<li>Macros and preprocessor directives</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
General rules</h2>
<p>Here are listed most obvious and important general rules. Please check them carefully before you continue with other chapters. </p>
<h2><a class="anchor" id="autotoc_md13"></a>
THE MOST IMPORTANT RULE IS TO RESPECT THE RULES !!!</h2>
<div class="fragment"><div class="line">- The language within source files shall be English throughout.</div>
<div class="line">- Use `C99` standard</div>
<div class="line">- Do not use tabs, use spaces instead</div>
<div class="line">- Use `4` spaces per indent level</div>
<div class="line">- Use `1` space between keyword and opening bracket</div>
<div class="line">- Always curly brakets have to start with one line bellow</div>
<div class="line">- Always when align comments they have to start afther `4` space/ 1 indent level from longest row from a grup</div>
<div class="line">- When a macro is defined as function use `3` indention or `3*4 = 12` space. If are more than one aligne like in example bellow.</div>
<div class="line">- When declare a variable, it have to be initialized</div>
<div class="line">- The <span class="keyword">interface </span>file shall have the extension <span class="stringliteral">&quot;.h&quot;</span> and the body file shall have the extension <span class="stringliteral">&quot;.c&quot;</span>.</div>
<div class="line">- There should not be more than one declaration on a line. -&gt; Clear implementation</div>
<div class="line">   uint8_t blockIndex, lastBlock; <span class="comment">/* violation */</span></div>
<div class="line">- Brackets shall always be used in complex expressions even <span class="keywordflow">if</span> the C priority rules <span class="keywordflow">do</span> not necessarily demand <span class="keyword">this</span> <span class="keywordflow">for</span> operators.</div>
<div class="line">  This also applies to expressions evaluated by the preprocessor.</div>
<div class="line">   <span class="keywordflow">if</span> ( (counter1 &gt; 0) || (counter2 &lt; 0) )</div>
<div class="line">   ...</div>
<div class="line">   #<span class="keywordflow">if</span> (SEC_SECURITY == C) || (SEC_SECURITY_CLASS == CCC)</div>
<div class="line">   ...</div>
<div class="line">   #endif</div>
<div class="line">- Do not insert a <span class="stringliteral">&quot;blank&quot;</span> before (or after) the <span class="stringliteral">&quot;.&quot;</span> and the <span class="stringliteral">&quot;-&gt;&quot;</span> operators.</div>
<div class="line">  This will harmonise the code style from different vendors, allowing easier reading and tool driven code checks</div>
<div class="line">- Operators <span class="stringliteral">&quot;++&quot;</span>, <span class="stringliteral">&quot;--&quot;</span>, <span class="stringliteral">&quot;&amp;&quot;</span> (functionAddress) , <span class="stringliteral">&quot;*&quot;</span> (FunctionRef) shall be stuck to their operand.</div>
<div class="line">  Common notation <span class="keywordflow">for</span> all Autosar source code makes it easier to review and automate <span class="keywordflow">for</span> tool checks.</div>
<div class="line">- Unary operators <span class="stringliteral">&quot;!&quot;</span> and <span class="stringliteral">&quot;~&quot;</span> (operators that only have a right operand) shall be stuck to their operand.</div>
<div class="line">  Avoid confusion with a binary <span class="keyword">operator</span>.</div>
<div class="line">   <span class="keywordflow">if</span>( ! computedBytes ) <span class="comment">/* violation */</span></div>
<div class="line">- Violations of MISRA rules shall be commented and reasoned at the corresponding code line.</div>
<div class="line">- Identifiers shall not contain the <span class="charliteral">&#39;_&#39;</span> character twice in succession.</div>
<div class="line">- Constants defined as a macro shall be written in upper <span class="keywordflow">case</span>. Digits and underscores are allowed but not at the start.</div>
<div class="line">- Each header file shall protect itself against multiple inclusion.</div>
<div class="line">  Avoid multiple re-definitions.</div>
<div class="line">   #ifndef FILENAME_H </div>
<div class="line"><span class="preprocessor">   #define FILENAME_H </span></div>
<div class="line">   ..... </div>
<div class="line"><span class="preprocessor">   #endif </span><span class="comment">/* FILENAME_H */</span><span class="preprocessor"></span></div>
<div class="line">- Each module shall include its own header file.</div>
<div class="line">  This is the only way of allowing the compiler to check <span class="keywordflow">for</span> consistency between declaration and definition of global variables and functions.</div>
<div class="line">- A <span class="stringliteral">&quot;.c&quot;</span> file shall not be included in another file: it shall be compiled and provided as an <span class="keywordtype">object</span> module.</div>
<div class="line">- A declaration with storage-<span class="keyword">class </span>specifier <span class="stringliteral">&quot;extern&quot;</span> shall exist for each global function in the header file of the module.</div>
<div class="line">  Allow access to global functions by including the header file of the defining module.</div>
<div class="line">- External declarations of global variables shall be done in header files and NEVER in .c files.</div>
<div class="line">  Provide access to global variables by including the header file of the module that defines the global variables.</div>
<div class="line">- Functions (other than macros) shall not be defined within in a <span class="stringliteral">&quot;.h&quot;</span> file.</div>
<div class="line">  Exception:</div>
<div class="line">  Definitions of inline functions in the header file are permitted.</div>
<div class="line">- Variables shall not be defined within in a &quot;.h&quot; file. They shall be defined within the module’s C file.</div>
<div class="line">  Rationale:</div>
<div class="line">  Prevent multiple variables, i.e. linker problem</div>
<div class="line">- Declarations of functions shall always be stated with detailed parameter list, i.e. the type and a practical designation of the relevant parameters.</div>
<div class="line">  Designator names in C and H file shall be identical.</div>
<div class="line">- Declaration and definition of local functions shall have the storage-class specifier “static”.</div>
<div class="line">  Local function means function with internal linkage (only visible inside the module).</div>
<div class="line">- Each self-defined type has to have an explicit type declaration even if there is only one variable of this type.</div>
<div class="line">- Multiple assignments shall not be done.</div>
<div class="line">   x = y = z; <span class="comment">/* violation */</span></div>
<div class="line">- The use of ‘++’ and ‘--‘ should be limited to simple cases. They shall not be used in statements where other operators occur. The prefix use is always forbidden.</div>
<div class="line">  This rule only belongs to ‘++’ and ‘--‘. Statements like ‘+=’ are excluded.</div>
<div class="line">  x -= y++; <span class="comment">/* violation */</span></div>
</div><!-- fragment --><p> c /* OK */ if (condition) /* if condition */ { /*...*/ } while (condition) /* While loop */ { /*...*/ } for (init; condition; step) /* for loop (the longest line form a grup)) */ { /*...*/ } do { /*...*/ } while (condition) /* do while loop*/</p>
<p>/* WRONG */ if(condition) while(condition) for(init;condition;step) do{} while(condition)</p>
<p>#define MARCRO_FUNCTION (x) foo(param)</p>
<p>/* More than one macro function */ #define MARCRO_FUNCTION (x) foo(param) #define MARCRO_FUNCTION_LONG (x, y) foo(param)</p>
<div class="fragment"><div class="line">- Do not use space between function name and opening bracket</div>
</div><!-- fragment --><p> c int32_t a = sum(4, 3); /* OK */ int32_t a = sum (4, 3); /* WRONG */ </p><div class="fragment"><div class="line">- Never use `__` or `_` prefix for variables/functions/macros/types. This is reserved for C language itself</div>
<div class="line">    - Prefer `prv_` name prefix for strictly module-private functions</div>
<div class="line">- Use only lowercase characters for variables/functions/macros/types with optional underscore `_` char</div>
<div class="line">- Opening curly bracket is always one line bellow as keyword (`for`, `while`, `do`, `switch`, `if`, `function`...)</div>
</div><!-- fragment --><p> c size_t i; for (i = 0; i &lt; 5; ++i) { /* OK */ }</p>
<p>for (i = 0; i &lt; 5; ++i){ /* WRONG */ } </p><div class="fragment"><div class="line">- Use single space before and after comparison and assignment operators</div>
</div><!-- fragment --><p> c int32_t a; a = 3 + 4; /* OK */ for (a = 0; a &lt; 5; ++a) /* OK */</p>
<p>a=3+4; /* WRONG */ a = 3+4; /* WRONG */ for (a=0;a&lt;5;++a) /* WRONG */</p>
<div class="fragment"><div class="line">- Use single space after every comma</div>
</div><!-- fragment --><p> c func_name(5, 4); /* OK */ func_name(4,3); /* WRONG */</p>
<div class="fragment"><div class="line">- Do not initialize `static` and `global` variables to `0` (or `NULL`), let compiler do it for you</div>
</div><!-- fragment --><p> c static int32_t a; /* OK */ static int32_t b = 4; /* OK */ static int32_t a = 0; /* WRONG */</p>
<p>void MyFunc(void) { static int32_t* ptr; /* OK */ static char abc = 0; /* WRONG */ } </p><div class="fragment"><div class="line">- Declare all local variables on the independent line</div>
</div><!-- fragment --><p> c void MyFunc(void) { char a; /* OK */ char b; /* WRONG */ char a, b; /* WRONG */ }</p>
<div class="fragment"><div class="line">- Declare local variables in order</div>
<div class="line">    1. Custom structures and enumerations</div>
<div class="line">    2. Integer types, wider unsigned type first</div>
<div class="line">    3. Single/Double floating point</div>
<div class="line">- Intialzize all the local variables</div>
<div class="line">- Align all the variables and the comments</div>
</div><!-- fragment --><p> c int MyFunc(void) { /* 1 */ MyStruct_st my = {0}; /* First custom structures */ MyStruct_st* p = {NULL}; /* Pointers too */ /* 2 */ uint32_t a = 0; int32_t b = 0; uint16_t c = 0; int16_t g = 0; char h = 0; /* ... */ /* 3 */ double d = 0; float f = 0; }</p>
<div class="fragment"><div class="line">- Always declare local variables at the beginning of the block, before first executable statement</div>
<div class="line">- DO NOT declare counter variables in `for` loop</div>
<div class="line">- All counter variables have to be `uint16`</div>
</div><!-- fragment --><p> c</p>
<p>/* OK */ uint16_t Idx; for (Idx = 0; Idx &lt; 10; ++Idx) { if (...) { break; } } if (Idx == 10) {</p>
<p>}</p>
<p>/* WRONG */ for (size_t i = 0; i &lt; 10; ++i) </p><div class="fragment"><div class="line">- Avoid variable assignment with function call in declaration, except for single variables</div>
</div><!-- fragment --><p> c void MyFunc(void) { /* Avoid function calls when declaring variable */ int32_t a, b = sum(1, 2);</p>
<p>/* Use this */ int32_t a = 0; int32_t b = 0; b = sum(1, 2);</p>
<p>/* This is NOT ok */ uint8_t a = 3, b = 4; }</p>
<div class="fragment"><div class="line">- Except `char`, `float` or `double`, always use types declared in `stdint.h` library, eg. `uint8_t` for `unsigned 8-bit`, etc.</div>
<div class="line">- Do not use `stdbool.h` library. Use `1` or `0` for `true` or `false` respectively</div>
</div><!-- fragment --><p> c /* OK */ uint8_t status = 0; status = 5;</p>
<p>/* WRONG */ #include &lt;stdbool.h&gt; bool status = true;</p>
<div class="fragment"><div class="line">- Never compare against `true`, eg. `if (check_func() == TRUE)`, use `if (check_func() != FALSE) { ... }`</div>
<div class="line">- Always compare pointers against `NULL` value</div>
</div><!-- fragment --><p> c /* OK */ if (check_func() != FALSE) { /* */ }</p>
<p>/* WRONG */ if (check_func() == TRUE) { /* */ }</p>
<p>void* ptr; /* OK, compare against NULL */ if (ptr == NULL || ptr != NULL) { /* ... */ }</p>
<p>/* WRONG */ if (ptr || !ptr) { /* ... */ }</p>
<div class="fragment"><div class="line">- Always use `size_t` for length or size variables</div>
<div class="line">- Always use `const` for pointer if function should not modify memory pointed to by `pointer`</div>
<div class="line">- Always use `const` for function parameter or variable, if it should not be modified</div>
</div><!-- fragment --><p> c</p>
<p>/* When d could be modified, data pointed to by d could not be modified */ void MyFunc(const void* d) { /* ... */ }</p>
<p>/* When d and data pointed to by d both could not be modified */ void MyFunc(const void* const d) { /* ... */ }</p>
<p>/* Not required, it is advised */ void MyFunc(const size_t len) { /* ... */ }</p>
<p>/* When d should not be modified inside function, only data pointed to by d could be modified */ void MyFunc(void* const d) { /* ... */ }</p>
<div class="fragment"><div class="line">- When function may accept pointer of any type, always use `void *`, do not use `uint8_t *`</div>
<div class="line">- Function must take care of proper casting in implementation</div>
</div><!-- fragment --><p> c /*</p><ul>
<li>To send data, function should not modify memory pointed to by <code>data</code> variable</li>
<li>thus <code>const</code> keyword is important</li>
<li></li>
<li>To send generic data (or to write them to file)</li>
<li>any type may be passed for data,</li>
<li>thus use <code>void *</code> */</li>
</ul>
<p>/* OK example */ void SendData(const void* data, size_t len) { /* OK */ /* Do not cast <code>void *</code> or <code>const void *</code> */ const uint8_t* d = data;/* Function handles proper type for internal usage */ }</p>
<p>/* WRONG, not not use int */ void SendData(const void* data, int len) { /* ... */ } </p><div class="fragment"><div class="line">- Always compare variable against zero, except if it is treated as `boolean` type</div>
<div class="line">- Never compare `boolean-treated` variables against zero or one. Use NOT (`!`) instead</div>
</div><!-- fragment --><p> c size_t length = 5; /* Counter variable */ uint8_t is_ok = 0; /* Boolean-treated variable */ if (length) /* WRONG, length is not treated as boolean */ if (length &gt; 0) /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */ if (length == 0) /* OK, length is treated as counter variable containing multi values, not only 0 or 1 */</p>
<p>if (is_ok) /* OK, variable is treated as boolean */ if (is_not_ok) /* OK, -||- */ if (is_ok == 1) /* WRONG, never compare boolean variable against 1! */ if (is_ok == 0) /* WRONG, use ! for negative check */</p>
<div class="fragment"><div class="line">- Always use `/* comment */` for comments, even for *single-line* comment</div>
<div class="line">- Every function must include *doxygen-enabled* comment, even if function is `static`</div>
<div class="line">- Use English names/text for functions, variables, comments</div>
<div class="line">- Use first characters Uppercase for variables</div>
<div class="line">- Use first character Uppercase for each word if variable contains multiple names, OK eg. `ForceRedraw` NOT OK `forceRedraw`</div>
<div class="line">- Never cast function returning `void *`, eg. `uint8_t* ptr = (uint8_t *)func_returning_void_ptr();` as `void *` is safely promoted to any other pointer type</div>
<div class="line">    - Use `uint8_t* ptr = func_returning_void_ptr();` instead</div>
<div class="line">- Always use `&lt;` and `&gt;` for C Standard Library include files, eg. `#include &lt;stdlib.h&gt;`</div>
<div class="line">- When casting to pointer type, always align asterisk to type, eg. `uint8_t* t = (uint8_t*)var_width_diff_type`</div>
<div class="line">- Always respect code style already used in project or library</div>
<div class="line"> </div>
<div class="line">## Comments</div>
<div class="line"> </div>
<div class="line">- Comments starting with `//` are not allowed. Always use `/* comment */`, even for single-line comment</div>
</div><!-- fragment --><p> c //This is comment (wrong) /* This is comment (ok) */ </p><div class="fragment"><div class="line">- For multi-line comments use `space+asterisk` for every line</div>
</div><!-- fragment --><p> c /*</p><ul>
<li>This is multi-line comments,</li>
<li>written in 2 lines (ok) */</li>
</ul>
<p>/**</p><ul>
<li>WRONG, use double-asterisk only for doxygen documentation */</li>
</ul>
<p>/*</p><ul>
<li>Single line comment without space before asterisk (wrong) */</li>
</ul>
<p>/*</p><ul>
<li>Single line comment in multi-line configuration (wrong) */</li>
</ul>
<p>/* Single line comment (ok) */</p>
<div class="fragment"><div class="line">## Functions</div>
<div class="line"> </div>
<div class="line">- Every function which may have access from outside its module, must include function *prototype* (or *declaration*)</div>
<div class="line">- Function name must be :</div>
</div><!-- fragment --><p> c returnType <a class="el" href="_naming___conventions_8c.html#a4c20a652838b8850a01825222d4b645f">ComponentName_FunctionName(type1 Argument1, type2 Argument2, ...)</a>;</p>
<p>/* Ok */ void MyFunc(void);</p>
<p>/* WRONG */ void MyFunc(void); void myfunc(void);</p>
<div class="fragment"><div class="line">- When function returns pointer, align asterisk to return type</div>
</div><!-- fragment --><p> c /* OK */ const char* MyFunc(void); MyStruct_st* MyFunc(int32_t a, int32_t b);</p>
<p>/* WRONG */ const char *MyFunc(void); MyStruct_st * MyFunc(void);</p>
<div class="fragment"><div class="line">- Align all function prototypes (with the same/similar functionality) for better readability</div>
<div class="line">- When function is setter or getter function use always `set` or `get` with *lowercase* in function name</div>
</div><!-- fragment --><p> c /* OK, function names aligned */ void ComponentName_setFunctionName(int32_t a); MyType_t ComponentName_getFunctionName(void); MyPtr_t* ComponentName_getFunctionName(void);</p>
<p>/* WRONG */ void set(int32_t a); const char * get(void);</p>
<div class="fragment"><div class="line">- Function implementation must include return type and optional other keywords in separate line</div>
</div><!-- fragment --><p> c /* OK */ int32_t foo(void) { </p><pre class="fragment">return 0;
</pre><p> }</p>
<p>/* OK */ static const char* getString(void) { return "Hello world!\r\n"; }</p>
<p>/* WRONG */ int32_t foo(void) { return 0; }</p>
<div class="fragment"><div class="line">- When new typedef is introduced for function handles, use `_fn` suffix</div>
</div><!-- fragment --><p> c /* Function accepts 2 parameters and returns uint8_t */ /* Name of typedef has <code>_fn</code> suffix */ typedef uint8_t (<em>MyFunc_typedef_fn)(uint8_t p1, const char</em> p2);</p>
<div class="fragment"><div class="line">## Variables</div>
<div class="line"> </div>
<div class="line">- Group local variables together by `type`</div>
<div class="line">- Initialize all the variables</div>
<div class="line">- Do not declare more than one variable on single line</div>
<div class="line">- Aligne all of them </div>
<div class="line">- Start first with special types definded by project</div>
<div class="line">- use indent of `4- spaces`</div>
</div><!-- fragment --><p> c /* OK */ void foo(void) { MyStruct_t a = {0}; MyStruct_t* pa = {NULL}; MyStruct_t* pb = {NULL}; int32_t a = 0; int8_t a = 0; char b = 0; } /* WRONG */ void foo(void) { MyStruct_t* pa; MyStruct_t * pb; int32_t a; char a,c,d; char b=0; MyStruct_t a; }</p>
<div class="fragment"><div class="line">- Do not declare variable after first executable statement</div>
</div><!-- fragment --><p> c void foo(void) { int32_t a = 0; a = bar(); int32_t b = 0; /* WRONG, there is already executable statement */ } </p><div class="fragment"><div class="line">- You may declare new variables inside next indent level</div>
</div><!-- fragment --><p> c int32_t a; a = foo(); if (a) { int32_t c = 0; int16_t d = 0; /* OK, c and d are in if-statement scope */ c = foo(); int32_t e = 0; /* WRONG, there was already executable statement inside block */ }</p>
<div class="fragment"><div class="line">- Declare pointer variables with asterisk aligned to type</div>
</div><!-- fragment --><p> c /* OK */ char* a; char* b;</p>
<p>/* WRONG */ char *a; char * b;</p>
<div class="fragment"><div class="line">## Structures, enumerations, typedefs</div>
<div class="line"> </div>
<div class="line">- The nave of the structure, enumeration or unions have to be:</div>
<div class="line">    `ComponentName_StructureName_st`</div>
<div class="line">    `ComponentName_EnumeartionName_et`</div>
<div class="line">    `ComponentName_UnionName_et`</div>
<div class="line">- Structure or enumeration may contain `typedef` keyword</div>
<div class="line">- All enumeration members must be uppercase with termination `_E`</div>
<div class="line">- Structure/enumeration must follow doxygen documentation syntax</div>
<div class="line">- When structure is declared  it *must* contain `_st` suffix after its name.</div>
</div><!-- fragment --><p> c</p>
<p>typedef struct { uint8_t Var1Template_u8; /* first variable used for... */ uint16_t Var2Template_u16; /* irst variable used for... */ uint8_t DummyHole_u8; /* dummy variable to fill the hole */ }<a class="el" href="struct_component_name___structure_name__st.html">ComponentName_StructureName_st</a>; /* _st -&gt; means structure type */</p>
<p>typedef enum { ELEMENT_NR0_E, ELEMENT_NR1_E, ELEMENT_NR2_E, ELEMENT_MAX_E /* always declare _MAX for an enum */ }ComponentName_EnumeartionName_et; /* _et -&gt; means enumeration type */</p>
<p>typedef union { uint16_t Word_u; /* comment to explain for what is used */ uint8_t ByteZero_c; /* comment to explain for what is used */ uint8_t ByteOne_c; /* comment to explain for what is used */ }<a class="el" href="union_component_name___union_name__ut.html">ComponentName_UnionName_ut</a>; /* _ut -&gt; means union type */</p>
<div class="fragment"><div class="line">- When initializing structure on declaration, use `C99` initialization style</div>
</div><!-- fragment --><p> c /* OK */ a_t a = { .a = 4, .b = 5, .c = 10, };</p>
<p>/* WRONG */ a_t a = {1, 2};</p>
<div class="fragment"><div class="line">## Compound statements</div>
<div class="line"> </div>
<div class="line">- Every compound statement must include opening and closing curly bracket, even if it includes only `1` nested statement</div>
<div class="line">- Every compound statement must include single indent; when nesting statements, include `1` indent size for each nest</div>
</div><!-- fragment --><p> c /* OK */ if (c) { do_a(); } else { do_b(); }</p>
<p>/* WRONG */ if (c) do_a(); else do_b();</p>
<p>/* WRONG */ if (c){ do_a();} else{ do_b(); }</p>
<p>/* WRONG */ if (c) do_a(); else do_b();</p>
<div class="fragment"><div class="line">- In case of `if` or `if-else-if` statement, `else` must be in the same line as closing bracket of first statement</div>
</div><!-- fragment --><p> c /* OK */ if (a) { /* ... */ } else if (b) { /* ... */ } else { /* ... */ }</p>
<p>/* WRONG */ if (a) {</p>
<p>} else {</p>
<p>}</p>
<p>/* WRONG */ if (a) {</p>
<p>} else {</p>
<p>}</p>
<div class="fragment"><div class="line">- In case of `do-while` statement, `while` part must be in the same line as closing bracket of `do` part</div>
</div><!-- fragment --><p> c /* OK */ do { int32_t a; a = do_a(); do_b(a); } while (check());</p>
<p>/* WRONG */ do{ /* ... */ } while (check());</p>
<p>/* WRONG */ do { /* ... */ } while (check());</p>
<div class="fragment"><div class="line">- Indentation is required for every opening bracket</div>
</div><!-- fragment --><p> c</p>
<p>if (a) { do_a(); } else { do_b(); if (c) { do_c(); } }</p>
<div class="fragment"><div class="line">- Never do compound statement without curly bracket, even in case of single statement. Examples below show bad practices</div>
</div><!-- fragment --><p> c /* Never */ if (a) do_b(); else do_c(); /* Never */ if (a) do_a(); else do_b();</p>
<div class="fragment"><div class="line">- Empty `while`, `do-while` or `for` loops must include brackets</div>
</div><!-- fragment --><p> c /* OK */ while (is_register_bit_set()) { /*... */ }</p>
<p>/* WRONG */ while (is_register_bit_set()); while (is_register_bit_set()) { } while (is_register_bit_set()) { } </p><div class="fragment"><div class="line">- If `while` (or `for`, `do-while`, etc) is empty (it can be the case in embedded programming), use empty single-line brackets</div>
</div><!-- fragment --><p> c /*</p><ul>
<li>Wait for bit to be set in embedded hardware unit</li>
<li>uint32_t* addr = HW_PERIPH_REGISTER_ADDR; */ while (<em>addr &amp; (1 &lt;&lt; 13)) { /</em> Wait bit 13 to be ready */ } /* OK, empty loop contains comment inside */</li>
</ul>
<p>while (<em>addr &amp; (1 &lt;&lt; 13)) { } /</em> WRONG */ while (<em>addr &amp; (1 &lt;&lt; 13)) { /</em> WRONG */</p>
<p>} while (<em>addr &amp; (1 &lt;&lt; 13)); /</em> WRONG, curly brackets are missing. Can lead to compiler warnings or unintentional bugs */ </p><div class="fragment"><div class="line">- Always prefer using loops in this order: `for`, `do-while`, `while`</div>
<div class="line">- Avoid incrementing variables inside loop block if possible, see examples</div>
<div class="line">- Always declare index as `uint16` with the *name* `Idx` or `Idx1, Idx2... Idxn`</div>
</div><!-- fragment --><p> c /* Not recommended */ int16_t Idx = 0; while (Idx &lt; 10) { .. ... ++Idx; }</p>
<p>/* Better */ for ( Idx = 0; Idx &lt; 10; ++Idx) {</p>
<p>}</p>
<p>/* Better, if inc may not happen in every cycle */ for ( Idx = 0; Idx &lt; 10; ) { if (...) { ++Idx; } }</p>
<div class="fragment"><div class="line">## Switch statement</div>
<div class="line"> </div>
<div class="line">- Add *single indent* for every `case` statement</div>
<div class="line">- Use additional *single indent* for `break` statement in each `case` or `default`</div>
</div><!-- fragment --><p> c /* OK, every case has single indent */ /* OK, every break has additional indent */ switch (check()) { case 0: do_a(); break; case 1: do_b(); break; default: break; }</p>
<p>/* WRONG, case indent missing */ switch (check()) { case 0: do_a(); break; case 1: do_b(); break; default: break; }</p>
<p>/* WRONG */ switch (check()) { case 0: do_a(); break; /* WRONG, break must have indent as it is under case */ case 1: do_b(); /* WRONG, indent under case is missing */ break; default: break; }</p>
<div class="fragment"><div class="line">- Always include `default` statement</div>
</div><!-- fragment --><p> c /* OK */ switch (var) { case 0: do_job(); break; default: break; }</p>
<p>/* WRONG, default is missing */ switch (var) { case 0: do_job(); break; }</p>
<div class="fragment"><div class="line">- If local variables are required, use curly brackets and put `break` statement inside.</div>
<div class="line">- Put opening curly bracket with a line bellow as `case` statement</div>
</div><!-- fragment --><p> c switch (a) { /* OK */ case 0: { int32_t a, b; char c; a = 5; /* ... */ break; }</p>
<p>/* WRONG */ case 1:{ int32_t a; break; }</p>
<p>/* WRONG, break shall be inside */ case 2: { int32_t a; } break; }</p>
<div class="fragment"><div class="line">## Macros and preprocessor directives</div>
<div class="line"> </div>
<div class="line">- Always use macros instead of literal constants, specially for numbers</div>
<div class="line">- All macros must be fully uppercase, with optional underscore `_` character, except if they are clearly marked as function which may be in the future replaced with regular function syntax</div>
</div><!-- fragment --><p> c /* OK */ #define MY_MACRO(x) ((x) * (x))</p>
<p>/* WRONG */ #define square(x) ((x) * (x))</p>
<div class="fragment"><div class="line">- Always protect input parameters with parentheses</div>
</div><!-- fragment --><p> c /* OK */ #define MIN(x, y) ((x) &lt; (y) ? (x) : (y))</p>
<p>/* WRONG */ #define MIN(x, y) x &lt; y ? x : y</p>
<div class="fragment"><div class="line">- Always protect final macro evaluation with parenthesis</div>
</div><!-- fragment --><p> c /* WRONG */ #define MIN(x, y) (x) &lt; (y) ? (x) : (y) #define SUM(x, y) (x) + (y)</p>
<p>/* Imagine result of this equation using wrong SUM implementation */ int32_t x = 5 * SUM(3, 4); /* Expected result is 5 * 7 = 35 */ int32_t x = 5 * (3) + (4); /* It is evaluated to this, final result = 19 which is not what we expect */</p>
<p>/* Correct implementation */ #define MIN(x, y) ((x) &lt; (y) ? (x) : (y)) #define SUM(x, y) ((x) + (y))</p>
<div class="fragment"><div class="line">- When macro uses multiple statements, protect it using `do-while (0)` statement</div>
</div><!-- fragment --><p> c typedef struct { int32_t px; int32_t py; }point_t; point_t p; /* Define new point */</p>
<p>/* WRONG implementation */</p>
<p>/* Define macro to set point */ #define SET_POINT(p, x, y) (p)-&gt;px = (x); (p)-&gt;py = (y) /* 2 statements. Last one should not implement semicolon */</p>
<p>SET_POINT(&amp;p, 3, 4); /* Set point to position 3, 4. This evaluates to... */ (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); /* ... to this. In this example this is not a problem. */</p>
<p>/* Consider this ugly code, however it is valid by C standard (not recommended) */ if (a) /* If a is true */ if (b) /* If b is true */ SET_POINT(&amp;p, 3, 4);/* Set point to x = 3, y = 4 */ else SET_POINT(&amp;p, 5, 6);/* Set point to x = 5, y = 6 */</p>
<p>/* Evaluates to code below. Do you see the problem? */ if (a) if (b) (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); else (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6);</p>
<p>/* Or if we rewrite it a little */ if (a) if (b) { (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); } else { (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6); }</p>
<p>/*</p><ul>
<li>Ask yourself a question: To which <code>if</code> statement <code>else</code> keyword belongs?</li>
<li></li>
<li>Based on first part of code, answer is straight-forward. To inner <code>if</code> statement when we check <code>b</code> condition</li>
<li>Actual answer: Compilation error as <code>else</code> belongs nowhere */</li>
</ul>
<p>/* Better and correct implementation of macro */ #define SET_POINT(p, x, y) do { (p)-&gt;px = (x); (p)-&gt;py = (y); } while (0) /* 2 statements. No semicolon after while loop */ /* Or even better */ #define SET_POINT(p, x, y) do { \ /* Backslash indicates statement continues in new line */ (p)-&gt;px = (x); \ (p)-&gt;py = (y); \ } while (0) /* 2 statements. No semicolon after while loop */</p>
<p>/* Now original code evaluates to */ if (a) if (b) do { (&amp;p)-&gt;px = (3); (&amp;p)-&gt;py = (4); } while (0); else do { (&amp;p)-&gt;px = (5); (&amp;p)-&gt;py = (6); } while (0);</p>
<p>/* Every part of <code>if</code> or <code>else</code> contains only <code>1</code> inner statement (do-while), hence this is valid evaluation */</p>
<p>/* To make code perfect, use brackets for every if-ifelse-else statements */ if (a) /* If a is true */ { if (b) /* If b is true */ { SET_POINT(&amp;p, 3, 4); /* Set point to x = 3, y = 4 */ } else { SET_POINT(&amp;p, 5, 6); /* Set point to x = 5, y = 6 */ } }</p>
<div class="fragment"><div class="line">- Avoid using `#ifdef` or `#ifndef`. Use `defined()` or `!defined()` instead</div>
</div><!-- fragment --><p> c #ifdef XYZ /* do something */ #endif /* XYZ */ </p><div class="fragment"><div class="line">- Always document `if/elif/else/endif` statements</div>
</div><!-- fragment --><p> c /* OK */ #if defined(XYZ) /* Do if XYZ defined */ #else /* defined(XYZ) */ /* Do if XYZ not defined */ #endif /* !defined(XYZ) */</p>
<p>/* WRONG */ #if defined(XYZ) /* Do if XYZ defined */ #else /* Do if XYZ not defined */ #endif </p><div class="fragment"><div class="line">- Do not indent sub statements inside `#if` statement</div>
</div><!-- fragment --><p> c /* OK */ #if defined(XYZ) #if defined(ABC) /* do when ABC defined */ #endif /* defined(ABC) */ #else /* defined(XYZ) */ /* Do when XYZ not defined */ #endif /* !defined(XYZ) */</p>
<p>/* WRONG */ #if defined(XYZ) #if defined(ABC) /* do when ABC defined */ #endif /* defined(ABC) */ #else /* defined(XYZ) */ /* Do when XYZ not defined */ #endif /* !defined(XYZ) */ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
